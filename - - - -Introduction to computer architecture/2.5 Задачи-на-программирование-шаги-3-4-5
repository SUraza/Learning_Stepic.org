Введение в архитектуру ЭВМ. Элементы операционных систем. модуль 2. 2.5 Задачи на программирование


Шаг - 3:
В этой задаче вам необходимо написать простую программу на ассемблере, которая выводит приветствие на экран. 
Для этого вам понадобится вызвать функцию puts и передать ей через стек строку с именем hello. Для этого вам 
понадобятся три инструкции:

push  $C - чтобы положить параметр С (в нашем случае hello) на стек
call  F - чтобы вызвать функцию с именем F (в нашем случае puts)
add $N, %esp - чтобы удалить со стека верхние N байт (esp - регистр указатель стека, стек растет вниз).
Адреса (а строка представляется адресом первого символа) в проверяющей системе 4 байтовые, соответственно, 
вы должны удалить со стека 4 байта занятые адресом строки hello.

Решение:

push $hello
call puts
add $4, %esp
end: nop

Шаг - 4:
В этой задаче вам потребуется написать ассемблерный код, который проверяет поместится ли сумма двух заданных
беззнаковых чисел в 32 битовый регистр. Числа поступают на вход в регистрах %eax и %edx. Если сумма чисел не
поместится в 32 битный регистр запишите в регистр %eax значение 0, если сумма поместится в 32 битный регистр, 
то запишите 1. Для выполнения этого задания вам потребуются следующие инструкции:

add %src, %dst  - складывает значение в регистре %src со значением в регистре %dst и сохраняет результат в регистр %dst
jc branch - передает управление коду с меткой branch, если в результате предыдущей операции произошло беззнаковое 
переполнение, в противном случае просто пропускается
jmp branch - передает управление коду с меткой branch
mov $C, %dst - записывает значение C в регистр %dst.


Решение:

add %eax, %edx                   
jc if_overflow                     
mov $1, %eax                       
jmp return                         
if_overflow:
    mov $0, %eax                  
return:

Шаг - 4:
В этом задании вы должны написать функцию возведения в степень. Функция принимает число в регистре %eax и показатель степени 
в регистре %edx, и возвращает результат в регистре %eax. Для выполнения этого задания вам потребуются следующие инструкции:

push %register и pop %register - если вы будете использовать регистры кроме %eax и %edx, 
то воспользуйтесь этой парой инструкций чтобы сохранить значение этих регистров в начале функции, 
а потом восстановить в конце (помните, что восстанавливать нужно в обратном порядке - так работает стек).
imul %src, %dst - эта инструкция умножает значения в регистрах %src и %dst и сохраняет результат в регистре %dst
test %register, %register - эта инструкция проверяет равно ли нулю значение в регистре %register и 
устанавливает специальный флаг ZF, если это так
jz branch - эта инструкция передает управление метке branch, если инструкция test установила флаг ZF 
(используйте ее в паре с test).
dec %register - эта инструкция уменьшает значение в регистре %register на 1
ret - инструкция завершает функцию, т. е. достает со стека адрес возврата и передает туда управление 
(чтобы достать со стека правильный адрес возврата, стек должен находится в таком же состояние, как и в самом начале функции)

Решение №1:
power:
    test %edx, %edx
    jz return1
    mov %eax, %ebx
    for:
        dec %edx
        test %edx, %edx
        jz return
        
        imul %ebx, %eax
        jmp for
    return:
        mov %eax, %eax
        ret
    return1:
        mov $1, %eax
        ret
        
Решение №2:
power:

push %ebx          # завожу временный регистр из стека
mov $1, %ebx       # кладу в него 1, если степень 0, то результат = 1 

begin_loop:        # начало цикла
test %edx, %edx    # проверяю, равен ли показатель степени 0
jz end_loop        # если равен, прекращаю цикл
imul %eax, %ebx    # умножаю!!!
dec %edx           # уменьшаю значение показателя степени на 1
jmp begin_loop     # иду в начало цикла
end_loop:          # выход из цикла
mov %ebx, %eax     # кладу результат из временного регистра в результирующий
pop %ebx           # возвращаю временный регистр в стек

    ret

Решение №3:
power:
    mov $1, %ecx # беру третью переменную кидаю туда 1(любое число в степени 0)
    
    umn:
    cmp $0, %edx # Сравниваю необходимую степень с 0
    je end # Если 0, то перехожу к метке возврата
    dec %edx # Если не 0, понижаю степень на 1
    imul %eax, %ecx # И домножаю третью переменную на основание
    jmp umn # Ну  и так до тех пор, пока степень не обнулится

    end:
    mov %ecx, %eax # Так как ответ нужен в регистре eax, перезаписываю туда свое кумулятивное произведение
    ret

Решение №4:
power:
    mov %eax, %ebx
    mov $1, %eax

do:
    test %edx, %edx
    jz done
    imul %ebx, %eax
    dec %edx
    jmp do

done:
    ret
